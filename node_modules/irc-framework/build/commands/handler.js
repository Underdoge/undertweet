'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _ = require('lodash');
var EventEmitter = require('eventemitter3');
var irc_numerics = require('./numerics');
var IrcCommand = require('./command');

module.exports = function (_EventEmitter) {
    _inherits(IrcCommandHandler, _EventEmitter);

    function IrcCommandHandler(connection, network_info) {
        _classCallCheck(this, IrcCommandHandler);

        // Adds an 'all' event to .emit()
        var _this = _possibleConstructorReturn(this, (IrcCommandHandler.__proto__ || Object.getPrototypeOf(IrcCommandHandler)).call(this));

        _this.addAllEventName();

        _this.connection = connection;
        _this.network = network_info;
        _this.handlers = [];

        _this.request_extra_caps = [];

        require('./handlers/registration')(_this);
        require('./handlers/channel')(_this);
        require('./handlers/user')(_this);
        require('./handlers/messaging')(_this);
        require('./handlers/misc')(_this);
        require('./handlers/generics')(_this);
        return _this;
    }

    _createClass(IrcCommandHandler, [{
        key: 'dispatch',
        value: function dispatch(message) {
            var irc_command = new IrcCommand(message.command.toUpperCase(), message);

            // Batched commands will be collected and executed as a transaction
            var batch_id = irc_command.getTag('batch');
            if (batch_id) {
                var cache = this.cache('batch.' + batch_id);
                if (cache) {
                    cache.commands.push(irc_command);
                } else {
                    // If we don't have this batch ID in cache, it either means that the
                    // server hasn't sent the starting batch command or that the server
                    // has already sent the end batch command.
                }
            } else {
                this.executeCommand(irc_command);
            }
        }
    }, {
        key: 'executeCommand',
        value: function executeCommand(irc_command) {
            var command_name = irc_command.command;

            // Check if we have a numeric->command name- mapping for this command
            if (irc_numerics[irc_command.command.toUpperCase()]) {
                command_name = irc_numerics[irc_command.command.toUpperCase()];
            }

            if (this.handlers[command_name]) {
                this.handlers[command_name].call(this, irc_command);
            } else {
                this.emitUnknownCommand(irc_command);
            }
        }
    }, {
        key: 'requestExtraCaps',
        value: function requestExtraCaps(cap) {
            this.request_extra_caps = _(this.request_extra_caps).concat(cap).uniq().value();
        }
    }, {
        key: 'addHandler',
        value: function addHandler(command, handler) {
            if (typeof handler !== 'function') {
                return false;
            }
            this.handlers[command] = handler;
        }
    }, {
        key: 'emitUnknownCommand',
        value: function emitUnknownCommand(command) {
            this.emit('unknown command', command);
        }

        // Adds an 'all' event to .emit()

    }, {
        key: 'addAllEventName',
        value: function addAllEventName() {
            var original_emit = this.emit;
            this.emit = function () {
                var args = Array.prototype.slice.call(arguments, 0);
                original_emit.apply(this, ['all'].concat(args));
                original_emit.apply(this, args);
            };
        }

        /**
         * Convert a mode string such as '+k pass', or '-i' to a readable
         * format.
         * [ { mode: '+k', param: 'pass' } ]
         * [ { mode: '-i', param: null } ]
         */

    }, {
        key: 'parseModeList',
        value: function parseModeList(mode_string, mode_params) {
            var chanmodes = this.network.options.CHANMODES || [];
            var prefixes = this.network.options.PREFIX || [];
            var always_param = (chanmodes[0] || '').concat(chanmodes[1] || '');
            var modes = [];
            var hasParam;
            var i;
            var j;
            var add;

            prefixes = _.reduce(prefixes, function (list, prefix) {
                list.push(prefix.mode);
                return list;
            }, []);
            always_param = always_param.split('').concat(prefixes);

            hasParam = function hasParam(mode, add) {
                var matchMode = function matchMode(m) {
                    return m === mode;
                };

                if (_.find(always_param, matchMode)) {
                    return true;
                }

                if (add && _.find((chanmodes[2] || '').split(''), matchMode)) {
                    return true;
                }

                return false;
            };

            j = 0;
            for (i = 0; i < mode_string.length; i++) {
                switch (mode_string[i]) {
                    case '+':
                        add = true;
                        break;
                    case '-':
                        add = false;
                        break;
                    default:
                        if (hasParam(mode_string[i], add)) {
                            modes.push({ mode: (add ? '+' : '-') + mode_string[i], param: mode_params[j] });
                            j++;
                        } else {
                            modes.push({ mode: (add ? '+' : '-') + mode_string[i], param: null });
                        }
                }
            }

            return modes;
        }

        /**
         * Cache object for commands buffering data before emitting them
         * eg.
         * var cache = this.cache('userlist');
         * cache.nicks = [];
         * cache.destroy();
         */

    }, {
        key: 'cache',
        value: function cache(id) {
            var cache;

            this._caches = this._caches || Object.create(null);
            cache = this._caches[id];

            if (!cache) {
                var destroyCacheFn = function destroyCacheFn(cache, id) {
                    return function () {
                        delete cache[id];
                    };
                };

                // We don't want the destoryCache to be iterable
                cache = Object.defineProperty({}, 'destroy', {
                    enumerable: false,
                    configurable: false,
                    value: destroyCacheFn(this._caches, id)
                });
                this._caches[id] = cache;
            }

            return cache;
        }
    }]);

    return IrcCommandHandler;
}(EventEmitter);